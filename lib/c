

class AuthService {
  static final _auth = FirebaseAuth.instance;

  static Future<User?> signInWithGoogle() async {
    if (kIsWeb) {
      try {
        final cred = await _auth.signInWithPopup(GoogleAuthProvider());
        return cred.user;
      } catch (_) {
        await _auth.signInWithRedirect(GoogleAuthProvider());
        return null;
      }
    } else {
      final google = GoogleSignIn.instance;
      await google.initialize(); // <- obbligatorio con 7.x
      final account = await google.authenticate();

      final tokens = account.authentication;
      final credential = GoogleAuthProvider.credential(idToken: tokens.idToken);

      final cred = await _auth.signInWithCredential(credential);
      return cred.user;
    }
  }

  static Future<void> signOut() async {
    if (!kIsWeb) {
      final google = GoogleSignIn.instance;
      await google.initialize();
      await google.signOut();
    }
    await _auth.signOut();
  }

  static Future<User?> signInWithGitHub(BuildContext context) async {
    if (kIsWeb) {
      final p = GithubAuthProvider()..addScope('read:user');
      try {
        return (await FirebaseAuth.instance.signInWithPopup(p)).user;
      } catch (_) {
        await FirebaseAuth.instance.signInWithRedirect(p);
        return null;
      }
    } else {
      final res = await GitHubSignIn(
        clientId: 'Ov23liD3laucH7pr5spL',
        clientSecret: 'c768426ad5de23cd33ff00d574d576f4674af7dc',
        redirectUrl: 'https://flowchart-thesis.firebaseapp.com/__/auth/handler',
      ).signIn(context);

      if (res.status != GitHubSignInResultStatus.ok || res.token == null) return null;
      final cred = GithubAuthProvider.credential(res.token!);
      return (await FirebaseAuth.instance.signInWithCredential(cred)).user;
    }
  }

  static   Future<void> signIn(String email, String password) async {
    await _auth.signInWithEmailAndPassword(
        email: email, password: password);
  }

  static   Future<User?> signUp(String email, String password) async {
    final cred = await _auth.createUserWithEmailAndPassword(
        email: email, password: password);
    if (cred.user != null) {
      await cred.user!.sendEmailVerification();
    }
    return cred.user;
  }
}


/// --- Helper per far “refreshare” GoRouter quando cambia l’auth --------------

class GoRouterRefreshStream extends ChangeNotifier {
  GoRouterRefreshStream(Stream<dynamic> stream) {
    _sub = stream.asBroadcastStream().listen((_) => notifyListeners());
  }
  late final StreamSubscription<dynamic> _sub;

  @override
  void dispose() {
    _sub.cancel();
    super.dispose();
  }
}

/// --- Home -------------------------------------------------------------------

class HomePage extends StatelessWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Flowchart Thesis'),
        actions: [
          IconButton(
            icon: const Icon(Icons.brightness_6),
            onPressed: () => Provider.of<ThemeProvider>(context, listen: false).toggleTheme(),
          ),
          if (user != null)
            IconButton(
              icon: const Icon(Icons.logout),
              onPressed: () async {
                await AuthService.signOut();
              },
            ),
        ],
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              user == null
                  ? 'Non sei loggato'
                  : 'Ciao ${user.email} (${user.uid.substring(0, 6)}...)',
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            const SizedBox(height: 30),
            if (user == null)
              ElevatedButton(
                onPressed: () => context.go('/login'),
                child: const Text('Vai al login'),
              ),
          ],
        ),
      ),
    );
  }
}
